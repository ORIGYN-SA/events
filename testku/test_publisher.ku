import Admin "../src/modules/admin"
import TestWallet "test_wallet"
import Full_Service "../src/main"
import Sample_Admin "sample_admin"

import C "mo:matchers/Canister"
import M "mo:matchers/Matchers"
import S "mo:matchers/Suite"
import T "mo:matchers/Testable"

import Buffer "mo:base/Buffer"
import D "mo:base/Debug"
import Iter "mo:base/Iter"
import Principal "mo:base/Principal"
import Result "mo:base/Result"

import Publish "../src/modules/publish";
import Subscribe "../src/modules/subscribe";

import CandyUtils "mo:candy_utils_0_2_0/CandyUtils";
import Candy "mo:candy_0_1_9/types";

import MigrationTypes "../src/migrations/types";

shared (deployer) actor class test_publisher() = this

  let State = MigrationTypes.Current

  type test_runner_service = actor {
    test: () -> async ({#success; #fail : Text})
  }

  type event_service = actor {
    registerPublication : (Text, Publish.PublicationOptions) -> async ()
    subscribe : (Text, Subscribe.SubscriptionOptions) -> async ()
    whoami: query () -> async Principal
  }

  let debug_channel =
    throws = true

  let it = C.Tester({ batchSize = 8 })

  let handled_events = Buffer.Buffer<Candy.CandyValue>(1)
  let handled_registrations = Buffer.Buffer<Result.Result<State.PublicationStable, Text>>(1)
  let handled_subscriptions = Buffer.Buffer<Result.Result<State.SubscriptionStable, Text>>(1)

  public shared (context) func handleEvent(event_id : Nat, canister_id: Principal, event_name : Text, payload : Candy.CandyValue) : async ()

    if(event_name == "com.droute.publication_confirmation")
      handled_events.add(payload)
      return

  public shared (context) func register_publication_response_droute(response : Result.Result<State.PublicationStable, Text>) : async ()
    D.print("register_publication_response_droute")
    handled_registrations.add(response)
    return

  public shared (context) func subscribe_response_droute(response : Result.Result<State.SubscriptionStable, Text>) : async ()
    handled_subscriptions.add(response)
    return
  

  public shared func test() : async {#success; #fail : Text}

    let suite = S.suite("test publisher", [
      S.test("testRegisterPublication", switch(await testRegisterPublication()){case(#success){true};case(_){false};}, M.equals<Bool>(T.bool(true)))
    ])
    S.run(suite)

    return #success


  public shared func testRegisterPublication() : async {#success; #fail : Text}
  
    let admin_service = await Sample_Admin.EventSystem();

    let admin_service_actor : event_service = actor(Principal.toText(Principal.fromActor(admin_service)))


    D.print("calling register")

    let future_reg = admin_service_actor.registerPublication("com.test", [#whitelist([Principal.fromActor(this)]), #confirm(Principal.fromActor(this))])

    D.print("was called")

    var handled_registration_count = handled_registrations.size()

    label waitForResponse for(thisItem in Iter.range(0,10))
      D.print("waiting on a round sub 2")
      let result = await admin_service_actor.whoami()
      if(handled_registrations.size() > handled_registration_count)
        break waitForResponse

    let suite = S.suite("test register publication", [
      S.test("fail if publication request not confirmed", switch(handled_registrations.getOpt(0))
        case(null){"item not found"}
        case(?x)
          matchr(x,
            if(val.eventName == "com.test")
              "found com.test"
            else
              "wrong event"
          ,
            "error: " # err
          )
      , M.equals<Text>(T.text("found com.test")))
    ])

    S.run(suite)

    return #success